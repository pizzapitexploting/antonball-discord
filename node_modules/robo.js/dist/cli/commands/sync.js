import { Command } from '../utils/cli-handler.js';
import { composeColors, color } from '../../core/color.js';
import { logger } from '../../core/logger.js';
import { getPackageManager } from '../utils/runtime-utils.js';
import { packageJson, getRoboPackageJson, PackageDir, findPackagePath } from '../utils/utils.js';
import { addAction } from './add.js';
import { removeAction } from './remove.js';
import { loadConfig } from '../../core/config.js';
import { prepareFlashcore, Flashcore } from '../../core/flashcore.js';
import { existsSync } from 'node:fs';
import path from 'node:path';

const command = new Command("sync").description("Syncs the Robo with the latest plugins and configurations").option("-s", "--silent", "do not print anything").option("-v", "--verbose", "print more information for debugging").option("-h", "--help", "Shows the available command options").handler(syncAction);
var sync_default = command;
async function syncAction(_args, options) {
  logger({
    enabled: !options.silent,
    level: options.verbose ? "debug" : "info"
  }).debug("Syncing Robo...");
  logger.debug("CLI options:", options);
  logger.debug(`Package manager:`, getPackageManager());
  logger.debug(`Robo.js version:`, packageJson.version);
  logger.debug(`Current working directory:`, process.cwd());
  let roboPackageJson;
  try {
    roboPackageJson = await getRoboPackageJson();
    logger.debug(`Syncing from Robo's package.json:`, roboPackageJson);
  } catch (error) {
    logger.warn(`Error reading package.json:`, error);
    return;
  }
  await loadConfig();
  await prepareFlashcore();
  const pluginRecord = await Flashcore.get("plugins", {
    namespace: ["robo", "sync"]
  }) ?? {};
  logger.debug("Plugin record:", pluginRecord);
  const time = Date.now();
  const pluginPaths = {};
  const allPlugins = (await Promise.all(
    Object.keys(roboPackageJson.dependencies || {}).map(async (packageName) => {
      let pluginPath = path.join(PackageDir, "..", packageName, ".robo");
      if (existsSync(pluginPath)) {
        pluginPaths[packageName] = path.join(pluginPath, "..");
        return packageName;
      }
      pluginPath = path.join(await findPackagePath(packageName, process.cwd()), ".robo");
      if (!existsSync(pluginPath)) {
        return null;
      }
      pluginPaths[packageName] = path.join(pluginPath, "..");
      return packageName;
    })
  )).filter(Boolean).sort();
  logger.debug(`Found ${allPlugins.length} total Robo plugins in ${Date.now() - time}ms:`, allPlugins);
  const addPlugins = allPlugins.filter((plugin) => {
    return !pluginRecord[plugin];
  });
  const pluginsInRecord = Object.keys(pluginRecord).sort();
  logger.debug(`Found ${addPlugins.length} new plugins to handled:`, addPlugins);
  const removePlugins = pluginsInRecord.filter((plugin) => !allPlugins.includes(plugin));
  logger.debug(`Found ${removePlugins.length} plugins to remove:`, removePlugins);
  if (addPlugins.length === 0 && removePlugins.length === 0) {
    logger.debug(composeColors(color.bold, color.green)("This Robo is up-to-date!"), "No sync required.");
    return;
  }
  if (addPlugins.length > 0) {
    logger.debug(addPlugins.length, `new plugin${addPlugins.length === 1 ? "" : "s"} detected.`);
    logger.debug("Registering new plugins:", addPlugins);
    try {
      const args = addPlugins.map((pkg) => {
        return isDependencyFromNpm(roboPackageJson.dependencies?.[pkg]) ? pkg : pluginPaths[pkg];
      });
      await addAction(args, {
        silent: options.silent,
        sync: true,
        verbose: options.verbose
      });
    } catch (error) {
      logger.error("Problem adding plugins:", error);
    }
  }
  if (removePlugins.length > 0) {
    logger.debug(removePlugins.length, `plugin${removePlugins.length === 1 ? "" : "s"} removed.`);
    logger.debug("Removing plugins:", removePlugins);
    try {
      await removeAction(removePlugins, {
        silent: options.silent,
        verbose: options.verbose
      });
      for (const plugin of removePlugins) {
        delete pluginRecord[plugin];
      }
    } catch (error) {
      logger.error("Problem removing plugins:", error);
    }
  }
  const newPayload = {
    ...allPlugins.reduce((acc, plugin) => {
      acc[plugin] = true;
      return acc;
    }, {})
  };
  logger.debug("Saving new plugin record:", newPayload);
  await Flashcore.set("plugins", newPayload, {
    namespace: ["robo", "sync"]
  });
}
function isDependencyFromNpm(versionSpec) {
  if (isValidSemver(versionSpec)) {
    return true;
  }
  try {
    const url = new URL(versionSpec);
    if (url.protocol === "http:" || url.protocol === "https:" || url.protocol === "git:") {
      return false;
    }
  } catch (e) {
  }
  if (versionSpec.startsWith("file:") || versionSpec.startsWith("link:") || path.isAbsolute(versionSpec) || versionSpec.startsWith("./") || versionSpec.startsWith("../") || versionSpec.startsWith("~") || process.platform === "win32" && /^[a-zA-Z]:[\\/]/.test(versionSpec)) {
    return false;
  }
  return true;
}
function isValidSemver(versionSpec) {
  const semverRegex = /^v?(?:\d+)(?:\.\d+){0,2}(?:-[\w-.]+)?(?:\+[\w-.]+)?$/;
  const rangeRegex = /^[\^~]?v?(?:\d+)(?:\.\d+){0,2}(?:-[\w-.]+)?(?:\+[\w-.]+)?$/;
  versionSpec = versionSpec.trim();
  return semverRegex.test(versionSpec) || rangeRegex.test(versionSpec) || versionSpec === "*";
}

export { sync_default as default };
